# 버퍼링

HDD가 메인 메모리까지 레코드를 가져오는 과정을 살펴보자.

1. CPU가 원하는 레코드의 블럭 주소를 전달
2. HDD가 해당 레코드가 담긴 블럭에 접근하여 메인 메모리에 전달

위와 같은 절차로 HDD에서 메인 메모리의 레코드(블록) 데이터가 전달이 된다. 그러나, HDD가 블록을 전송하는데에는 상당히 많은 시간이 걸린다(`ms` 단위). 그렇기에 CPU가 원하는 레코드의 블럭 주소가 매번 다르다면 그때마다 HDD는 바쁘게 데이터를 전달해주어야 한다.

이런 문제 때문에 버퍼링 기법이 등장했다.

> 버퍼링
> 버퍼라는 데이터가 담기는 임의의 공간을 구축하여, HDD가 가져다 놓을 수 있도록 한다. 따라서 CPU가 버퍼에 담긴 데이터로 작업을 처리하는 동안 HDD는 또 다른 블럭에 접근하여 새로운 데이터를 가져올 수 있게 된다.

### 싱글 버퍼링 vs. 더블 버퍼링

버퍼의 개수에 따라 버퍼링 기법을 `싱글 버퍼링`과 `더블 버퍼링`으로 나눌 수 있다.

1. 싱글 버퍼링: 버퍼의 개수가 1개인 버퍼링 기법.
2. 더블 버퍼링: 버퍼의 개수가 2개인 버퍼링 기법. 효율성 측면에서 우월함.

일반적으로 더블 버퍼링을 많이 사용한다. 물을 마시는데 정수기에서 물이 계속 나오고 있다고 가정해보자. 컵을 2개 사용해 한 컵으로 물을 마시는 동안 다른 컵에 물을 받아놓으면 컵을 1개 사용하는 것보단 빠르게 마실 수 있다.

이런 버퍼의 개수를 **버퍼 풀(buffer pool)** 이라고 칭한다.

### 버퍼 관리

메인 메모리가 계속해서 블록(페이지)를 요청한다고 해보자. 버퍼 풀이 2라고 할 때, HDD가 새롭게 가져온 페이지를 아무 버퍼에 교체해도 괜찮을까?
그렇지 않다. 메인 메모리가 해당 페이지를 쓰고 있을 수 있기 때문이다.

이 문제를 해결하기 위해 필요한 버퍼의 정보가 있다.

- pin-count
  - 현재 할당된 버퍼를 몇 개의 프로세서가 쓰고 있는지에 대한 정보
- dirty bit
  - 만약, 버퍼에 존재하는 페이지가 수정되었다면 HDD에도 수정해주어야 한다. 이를 판별하기 위한 비트가 **dirty bit**이다.

### 버퍼 교체 전략

- LRU: 가장 최근에 쓰이지 않은 버퍼를 교체하는 방법
- Clock policy: 교대로 교체하는 방법
- FIFO: 먼저 들어온 버퍼를 교체하는 방법
- MRU: 가장 최근에 쓰인 버퍼를 교체하는 방법
